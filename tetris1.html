<!DOCTYPE html>
<html>
 <body>
    
    <script>
// Function to check if we can place all the provided shapes in the given area
function canPlaceShapesInArea(area, shapes) {

  	//Speedhack_1: check #of shape squares and #of area squares match
    const totalShapeSquares = shapes.reduce((acc, shape) => acc + shape.length, 0);
    //console.log('shape_squares: ' +totalShapeSquares);
    //console.log('area_squares: ' area.length);
    if (totalShapeSquares !== area.length) {
        return false; // Quick exit
    }

	//Speedhack_2_TODO: skip testing base square of shapes and remove that square from all shapes. Then ensure it is 'consumed' properly when all other shape squares fit.
    

    // Ensure that the shapes parameter is an array.
    if (!Array.isArray(shapes)) {
        throw new Error("The shapes parameter must be an array.");
    }

    // Helper function to attempt placing a single shape into the area.
    function canPlaceSingleShape(area, shape, xOffset, yOffset) {

        for (let block of shape) {
            let absoluteX = block.x + xOffset;
            let absoluteY = block.y + yOffset;

            // Check if this block's position exists in the area.
            if (!area.some(pos => pos.x === absoluteX && pos.y === absoluteY)) {
                return false; // The shape can't fit here.
            }
        }
        return true; // The shape fits at this position.
    }

    // Recursive function to attempt placing all shapes in the area.
    function recursiveFit(area, remainingShapes) {
        if (remainingShapes.length === 0) {
            return area.length === 0; // If no remaining shapes, ensure the area is also empty.
        }

        let currentShape = remainingShapes[0];
        for (let position of area) {

            if (canPlaceSingleShape(area, currentShape, position.x, position.y)) {
                // Construct a new area without the blocks of the placed shape.
                const newArea = area.filter(block => {
                    return !currentShape.some(shapeBlock => 
                        shapeBlock.x + position.x === block.x && shapeBlock.y + position.y === block.y
                    );
                });

                // Recursively attempt to fit the rest of the shapes in the new area.
                if (recursiveFit(newArea, remainingShapes.slice(1))) {
                    return true;
                }
            }
        }
        return false; // Couldn't fit the shapes into the area.
    }

    return recursiveFit(area, shapes);
}

// Example shape
const exampleShape = [
    {x: 1, y: 0},
    {x: 2, y: 0},
    {x: 0, y: 1},
    {x: 1, y: 1}
];




// Example area
const exampleArea = [
{x: 0, y: 4},
{x: 1, y: 4},
{x: 2, y: 4},
{x: 1, y: 3}
];


// Test
console.log(canPlaceShapesInArea(exampleArea, [normalizeShape(exampleShape)])); // Should return true or false


function normalizeShape(shape) {
  // Find the minimum x and y values in the shape
  let minX = Infinity;
  let minY = Infinity;

  // Find the lowest x value, and then find the lowest y that matches that x. we need these two numbers to normalize the shape and reduce the coords to wrap around a single 0,0 origin
  // It makes no difference if we first looked for the lowest y etc.
  for (const block of shape) {
    if (block.x < minX) {
      minX = block.x;
    }
    
  }

  for (const block of shape) {
    if (block.x === minX) {
      if (block.y < minY) {
            minY = block.y;
        }
    }
    
  }

  // Shift all coordinates by the minimum values to normalize
  const normalizedShape = shape.map(block => ({
    x: block.x - minX,
    y: block.y - minY,
  }));

  return normalizedShape;
}


const adjustedShape = normalizeShape(exampleShape);
console.log(adjustedShape);

    </script>
</body>
</html>
