<!DOCTYPE html>
<html>
<body>

<canvas id="myCanvas" width="6000" height="300" style="border:1px solid #000000;">


<script>
const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");

const SQUARE_SIZE = 40; // Size of a square
const GAP_SIZE = SQUARE_SIZE / 8; // Gap between Tetris shape squares
const SHAPE_COLOR = "#00000"; // Arbitrary color for the shape

function drawTetrisShape(x, y, shape) {
    console.log(shape);
    // x and y are the starting positions on the grid

    shape.forEach(square => {
        const xPos = x + (square.x * (SQUARE_SIZE + GAP_SIZE));
        const yPos = y + (square.y * (SQUARE_SIZE + GAP_SIZE));

        ctx.fillStyle = 'orange';
        ctx.fillRect(xPos, yPos, SQUARE_SIZE, SQUARE_SIZE);
    });
}

function normalizeShape(shape) {
  // Find the minimum x and y values in the shape
  let minX = Infinity;
  let minY = Infinity;

  // Find the lowest x value, and then find the lowest y that matches that x. we need these two numbers to normalize the shape and reduce the coords to wrap around a single 0,0 origin
  // It makes no difference if we first looked for the lowest y etc.
  for (const block of shape) {
    if (block.x < minX) {
      minX = block.x;

        if (block.y < minY) {
            minY = block.y;
        }
    }
    
  }

  // Shift all coordinates by the minimum values to normalize
  const normalizedShape = shape.map(block => ({
    x: block.x - minX,
    y: block.y - minY,
  }));

  return normalizedShape;
}

function transformShape(shape, flipHorizontal = false, flipVertical = false, rotation = 0) {
    // Get the maximum x and y values from the shape.
    const maxX = Math.max(...shape.map(s => s.x));
    const maxY = Math.max(...shape.map(s => s.y));

    return shape.map(s => {
        let newX = s.x;
        let newY = s.y;

        // Handle rotations
        switch (rotation % 360) {
            case 90:
                newX = s.y;
                newY = maxX - s.x;
                break;
            case 180:
                newX = maxX - s.x;
                newY = maxY - s.y;
                break;
            case 270:
                newX = maxY - s.y;
                newY = s.x;
                break;
        }

        // Handle flips
        if (flipHorizontal) newX = maxX - newX;
        if (flipVertical) newY = maxY - newY;

        return { x: newX, y: newY };
    });
}

const monomino = [
    {x: 0, y: 0}
];

const domino = [
    {x: 0, y: 0},
    {x: 0, y: 1}
];

const domino_R90 = transformShape(domino, false, false, 90);

const tromino_Right = [
    {x: 0, y: 0},
    {x: 1, y: 0},
    {x: 0, y: 1}
];
const tromino_Right_R90 = transformShape(tromino_Right, false, false, 90);
const tromino_Right_R180 = transformShape(tromino_Right, false, false, 180);
const tromino_Right_R270 = transformShape(tromino_Right, false, false, 270);


const tromino_Straight = [
    {x: 0, y: 0},
    {x: 0, y: 1},
    {x: 0, y: 2}
];
const tromino_Straight_R90 = transformShape(tromino_Straight, false, false, 90);

const tetromino_Square = [
    {x: 0, y: 0},
    {x: 0, y: 1},
    {x: 1, y: 0},
    {x: 1, y: 1}
];

const tetromino_L = [
    {x: 0, y: 0},
    {x: 0, y: 1},
    {x: 0, y: 2},
    {x: 1, y: 2}
];
const tetromino_L_R90 = transformShape(tetromino_L, false, false, 90);
const tetromino_L_R180 = transformShape(tetromino_L, false, false, 180);
const tetromino_L_R270 = transformShape(tetromino_L, false, false, 270);
// "R"
const tetromino_L_FH = transformShape(tetromino_L, true, false);
const tetromino_L_FH_R90 = transformShape(tetromino_L, true, false, 90);
const tetromino_L_FH_R180 = transformShape(tetromino_L, true, false, 180);
const tetromino_L_FH_R270 = transformShape(tetromino_L, true, false, 270);


const tetromino_Skew = [
    {x: 1, y: 0},
    {x: 2, y: 0},
    {x: 0, y: 1},
    {x: 1, y: 1}
];
const tetromino_Skew_R90 = transformShape(tetromino_Skew, false, false, 90);
const tetromino_Skew_FH = transformShape(tetromino_Skew, true, false);
const tetromino_Skew_FH_R90 = transformShape(tetromino_Skew, true, false, 90);


const tetromino_T = [
    {x: 0, y: 0},
    {x: 1, y: 0},
    {x: 2, y: 0},
    {x: 1, y: 1}
];
const tetromino_T_R90 = transformShape(tetromino_T, false, false, 90);
const tetromino_T_R180 = transformShape(tetromino_T, false, false, 180);
const tetromino_T_R270 = transformShape(tetromino_T, false, false, 270);


const tetromino_Straight = [
    {x: 0, y: 0},
    {x: 0, y: 1},
    {x: 0, y: 2},
    {x: 0, y: 3}
];
const tetromino_Straight_R90 = transformShape(tetromino_Straight, false, false, 90);


drawTetrisShape(0, 100, monomino);
drawTetrisShape(200, 100, domino);
drawTetrisShape(400, 100, domino_R90);
drawTetrisShape(600, 100, tromino_Right);
drawTetrisShape(800, 100, tromino_Right_R90);
drawTetrisShape(1000, 100, tromino_Right_R180);
drawTetrisShape(1200, 100, tromino_Right_R270);
drawTetrisShape(1400, 100, tromino_Straight);
drawTetrisShape(1600, 100, tetromino_Straight_R90);
drawTetrisShape(1800, 100, tetromino_Square);
drawTetrisShape(2000, 100, tetromino_L);
drawTetrisShape(2200, 100, tetromino_L_R90);
drawTetrisShape(2400, 100, tetromino_L_R180);
drawTetrisShape(2600, 100, tetromino_L_R270);
drawTetrisShape(2800, 100, tetromino_L_FH);
drawTetrisShape(3000, 100, tetromino_L_FH_R90);
drawTetrisShape(3200, 100, tetromino_L_FH_R180);
drawTetrisShape(3400, 100, tetromino_L_FH_R270);
drawTetrisShape(3600, 100, tetromino_Skew);
drawTetrisShape(3800, 100, tetromino_Skew_R90);
drawTetrisShape(4000, 100, tetromino_Skew_FH);
drawTetrisShape(4200, 100, tetromino_Skew_FH_R90);
drawTetrisShape(4400, 100, tetromino_T);
drawTetrisShape(4600, 100, tetromino_T_R90);
drawTetrisShape(4800, 100, tetromino_T_R180);
drawTetrisShape(5000, 100, tetromino_T_R270);
drawTetrisShape(5200, 100, tetromino_Straight);
drawTetrisShape(5400, 100, tetromino_Straight_R90);







</script>

</canvas>

</body>
</html>

